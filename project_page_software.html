<!DOCTYPE HTML>
<!--
	Massively by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
	<head>
		<title>Generic Page - Massively by HTML5 UP</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="assets/css/main.css" />
		<noscript><link rel="stylesheet" href="assets/css/noscript.css" /></noscript>
	</head>
	<body class="is-preload">

		<!-- Wrapper -->
        <div id="wrapper">

            <!-- Header -->
            <header id="header">
                <a href="index.html" class="logo">Project Page</a>
            </header>

            <!-- Nav -->
            <nav id="nav">
                <ul class="links">
                    <li><a href="index.html">Home</a></li>
                    <li class="active"><a href="project_pipeline.html">Software</a></li>
                </ul>
                <ul class="icons">
                    <li><a href="#" class="icon brands fa-github"><span class="label">GitHub</span></a></li>
                </ul>
            </nav>

            <!-- Main -->
            <div id="main">
                <section>
                    <header class="major">
                        <h1>
                            Software for shape modelling and registration
                        </h1>
                        <p> Filipa Valdeira</p>
                    </header>
                    <p>
                        During the progress of this work and extensive amount of python code was developed which makes the modelling and shape registration an easier taks.
                        This creates useful classes for handling registered and non registered datasets, as well as an easy extension of registration to new methods or different kinds of data.
                        The two developed methods are then provided in encapsulated functions which do not require any knlowedge of this underlying library.
                        Nonetheless, this can be a useful tool for anyone working in this field.
                    </p>
                    <p>
                        When convinient we rely on the open-source library <a href="http://www.open3d.org/docs/release/index.html#">Open3D</a> specifically developed to handle 3D data. Partciularly, when handling meshes we resort to
                        their functions for input/output or mesh creation from a point cloud.
                    </p>
                    <p>
                        The main components of this library are the modules <i>shapes</i>, <i>registration</i> and <i>models</i>. The first implements classes for individual shapes and full datasets,
                        either registered or not, and allows for shape transformations while keeping track of their correspondences. The second handles different registration methods for a given dataset.
                        The last produces low dimensional models which can be used only for registered datasets.

                    </p>
                </section>

                <section>
                    <h1>shapes</h1>
                    In this module there are 3 important classes on the user point of view:
                    <ul>
                        <li>Shape - handles each shape element, either a point cloud (only vertices) or a mesh (vertices and faces) </li>
                        <li>ShapeDataset - handles a set of shape elements (all of the same type) and includes methods for plotting, transforming shapes or saving them to files.</li>
                        <li>
                            RegDataset - handles a set of registered shape elements with respect to a given template, obtained from the registration procedure. Includes the deformed template obtained from the
                            registration as well as the correspondence vectors for each shape.
                        </li>
                    </ul>

                    <h2>ShapeDataset</h2>

                    A dataset must be instanciated with a given dimension <i>dim</i>, which all its shapes must respect

                    <pre><code>from dataset import ShapeDataset

dim = 3
dataset = ShapeDataset(dim)</code></pre>


                    <h3>Adding new shapes</h3>
                    New shapes can be added with methods <i>add_mesh</i> or <i>add_shape</i>, depending on the type of data. The set of shapes is then stored in a dictionary <i>shapes_dict</i>,
                    with the respective shape <i>id</i> has keys and an object <i>shape</i> as values. Below we provide an example to add a new a mesh and a new point set -
                    note that different kinds cannot be included in the same dataset.

                    <p>
                        <b>Adding a new point set shape</b>
                        <pre><code>import numpy as np

id = 0
pts = np.random.rand(20,3)
dataset.add_shape(id, pts)</code></pre>

                    </p>

                    <p>
                        <b>Adding a new mesh shape</b>
                        <pre><code>import numpy as np

id = 0
vertices = np.random.rand(20, 3)
faces = np.random.randint(0, 20, (30,3))
dataset.add_mesh(id, vertices, faces)</code></pre>

                    </p>

                    <!-- Noisy datasets -->
                    <h3>Creating altered datasets</h3>

                    The following methods return a new ShapeDataset with a given modification.
                    They can be applied to specific shapes by defining <i>id_list</i>. Below we provide an example of a modification.
                    <ul>
                        <li>struct_missing_data - removes data points in a given bounding box </li>
                        <li>struct_missing_data_ID - removes data points by their id </li>
                        <li>random_missing_data - randomly removes a given percentage of data points </li>
                        <li>random_noisy_data - adds noise with a given variance to each data point </li>
                        <li>outliers_uniform - randomly places a given ratio of outliers within a bounding box of each shape</li>
                        <li>outliers_struct - randomly places a given ratio of outliers within a defined region </li>
                    </ul>

                    <pre><code>id_list = [2,3,4]
miss_ratio = 0.8
dataset_transf = dataset.random_missing_data(miss_ratio,id_list)
</code></pre>

                    <h3>Saving shapes to files</h3>
                    All the shapes in the dataset can be saved into a <i>dest_folder</i> with different file formats. If one wishes to save
                    obly the shape points the available formats are '.csv' and '.txt'. For meshes, there are '.ply' or '.stl' - if a dataset has only
                    point clouds, 3D meshes will be generated with Open3D. Below is an example of this method.
                    <pre><code>dest_folder = './Results'
file_type = 'ply'
dataset.save_to_files(dest_folder,file_type)</code></pre>

                    <h2>RegDataset</h2>

                    This object is obtained as an output of a registration method. It contains information on the registration method used and the
                    results obtained - the deformed template for each shape and the retrieved correspondences.
                    We cover the most important attributes and methods from the user point of view.

                    <p>
                        <h3>Results from registration</h3> The following attributes contain the output from any registration method.
                        <ul>
                            <li>
                                corr_by_template - dictionary with keys as shapes ids and values are a list of correspondences in the point of view of the template,
                                i.e. the number of elements equals the number of target points, the ids indicate the target point for a given template point and 'nan' values
                                indicate  a missing point.
                            </li>
                            <li>corr_by_target - similar to corr_by_template but in the point of view of the target. </li>
                            <li>def_src_dict - dictionary where each shape id is associated to the deformed template matrix obtained  </li>
                        </ul>
                    </p>

                    <p>
                        <h3>Useful plotting functions</h3> The following are useful methods to plot registered shapes where one can visualize the correspondences obtained.
                        Note that these are mostly suitable for 2D data.
                        <ul>
                            <li>
                                plot_2_shapes - plots 2 different shapes in the dataset with the correspondences obtained. For a more clear result, a subset of correspondences
                                can be specified. Non connected points are also identified.
                            </li>
                            <li>
                                plot_template_and_shape - plots two figures, one with the original template and the target, and one with the deformed template and the target.
                                Both include the visualization of the correspondences.
                            </li>
                        </ul>
                        Below we show how to call this method with all correspondences visible and a representative result.
                        <pre><code>id = 1
reg_dataset.plot_template_and_shape(id, begin = 0, end = 'all')</code></pre>
                    </p>

                    <h3>Output shapes</h3>



                </section>


                <section>

                    <h1>Registration</h1>

                    The main classes here are ShapesRegistration - to perform registration with different methods - and RegMetrics - to evaluate results from resgistration under different metrics.

                    <p>
                        <h2>ShapesRegistration</h2>
                        This is a generic class that can then be used to create new classes for a desired method by implementing the method <i>pair_registration</i>.
                        We will first give an overview of the class and then explain how to implement  <i>pair_registration</i>. Currently, the implemented methods are ICP, NICP, BCPD and GPReg.
                    </p>

                    <p>
                        <h3>simple_registration</h3>
                        The way to perform registration is with a call to the method <i>simple_registration</i>, which receives as input a template,
                        a ShapeDataset object and an <i>id_list</i> of the shapes to register. The registration can be performed in parallel by setting the flag <i>flag_parallel</i> to true.
                        The output is an object of class RegDataset.
                    </p>

                    <p>
                        <h3>Create a registration method class </h3>
                        Any registration class inherits from ShapesRegistration. Then its specific attributes can be defined and the method pair_registration must be implemented.

                    </p>

                    <p>
                        <i> pair_registration</i>  receives as input two numpy matrices, the target and the source - the source must be deformed to fit the target.
                        The specific steps of the method are then implemented. It must return a numpy matrix of the same dimensions as the source with its deformed version and
                        a correspondence vecotr with the ids of the target corresponding to each template point - if no correspondence is found that element is set to nan.
                    </p>

                    <p>
                        <h3>Usage </h3>
                        Below we present an example of usage for the registration with ICP.
                        <pre><code>max_dist = 0.25
icp_reg = IcpRegistration(reg_type = 'point_to_point', max_dist=max_dist, scaling=False)
flag_parallel = False
id_list = 'all'
reg_dataset = icp_reg.simple_registration(template, dataset, id_list, flag_parallel)    
</code></pre>
                    </p>

                    <!-- RegMetrics -->

                    <p>
                        <h2>RegMetrics</h2>
                        This class requires as input one object ShapeDataset with the original dataset and one object RegDataset with the output of a registration procedure.
                        It computes a given number of pertinent metrics and displays the results. Below we describe the most useful methods.
                    </p>
                    <p>
                        <b>plot_dist_metrics_by_shape</b> - produces 3 bar plots with 3 different distance measures: average distance between the deformed template and target,
                        average difference between the original template and target and average difference in the target for correspondences found.

                        <img src="images/reg_metrics_pic_distances.png" width="599" height="660" alt="" />
                    </p>
                    <p>
                        <b>plot_corr_metrics_by_shape</b> -  plots correspondences metrics by shape
                    </p>
                    <p>
                        <b>plot_outlier_metric_by_shape</b> -   plots outliers metrics by shape (accuracy, recall and precision)
                    </p>                   
                    <p>
                        <b>plot_missing_metric_by_shape</b> -  plots missing data metrics by shape (accuracy, recall and precision)
                    </p>                   
                   

                </section>



                <!-- Post -->
                <section class="post">

                    <h2>Documentation and useful links</h2>
                    <div class="box">
                        <h3><a href="https://ieeexplore.ieee.org/document/9534754?source=authoralert">Paper</a></h3>
                        <p> F. Valdeira, R. Ferreira, A. Micheletti and C. Soares, "From Noisy Point Clouds to Complete Ear Shapes: Unsupervised Pipeline," in IEEE Access, vol. 9, pp. 127720-127734, 2021, doi: 10.1109/ACCESS.2021.3111811. </p>
                        <h3><a href="https://github.com/filva/shapes_pipeline">Code</a></h3>
                        <p> Github repository with the implementation of the pipeline. </p>
                    </div>

                </section>
            </div>
            <!-- Copyright -->
            <div id="copyright">
                <ul><li>&copy; Untitled</li><li>Design: <a href="https://html5up.net">HTML5 UP</a></li></ul>
            </div>

        </div>

		<!-- Scripts -->
			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/jquery.scrollex.min.js"></script>
			<script src="assets/js/jquery.scrolly.min.js"></script>
			<script src="assets/js/browser.min.js"></script>
			<script src="assets/js/breakpoints.min.js"></script>
			<script src="assets/js/util.js"></script>
			<script src="assets/js/main.js"></script>

	</body>
</html>